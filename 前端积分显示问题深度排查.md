# 前端积分显示问题深度排查

## 问题描述

即使在清除缓存、强制刷新并重新登录后，前端仍然显示积分为0，而数据库中的实际值是20。

## 可能的原因

1. **前端API调用问题**：前端可能没有正确调用API获取用户数据
2. **数据转换问题**：API返回的数据可能没有被正确解析
3. **状态管理问题**：用户状态可能没有正确更新
4. **组件渲染问题**：组件可能没有正确使用用户状态
5. **RLS策略问题**：RLS策略可能阻止了前端获取积分数据

## 深度排查步骤

### 1. 检查前端API调用

在浏览器控制台中执行以下代码，直接测试API调用：

```javascript
const { data, error } = await window.supabase
  .from('users')
  .select('credits, email')
  .eq('email', '当前登录的邮箱')
  .single();

console.log('API调用结果:', data, error);
```

### 2. 检查RLS策略是否正确应用

确认RLS策略允许用户读取自己的积分：

```sql
-- 在SQL编辑器中执行
SELECT * FROM pg_policies WHERE tablename = 'users';
```

### 3. 检查用户认证状态

在浏览器控制台中执行：

```javascript
const { data: { session } } = await window.supabase.auth.getSession();
console.log('当前会话:', session);
```

### 4. 检查前端状态管理

在React开发者工具或Vue开发者工具中检查用户状态是否包含积分信息。

### 5. 创建测试脚本

创建一个`test-credits-api.js`文件：

```javascript
// 测试积分API
const { createClient } = require('@supabase/supabase-js');

// Supabase配置
const supabaseUrl = 'https://gdcjvqaqgvcxzufmessy.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdkY2p2cWFxZ3ZjeHp1Zm1lc3N5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyMDY2NTEsImV4cCI6MjA2OTc4MjY1MX0.wIblNpUZLgQcCJCVbKfae5n0jtcIshL9asVIit6iUBI';
const supabase = createClient(supabaseUrl, supabaseKey);

async function testCreditsAPI() {
  try {
    // 1. 获取当前会话
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      console.log('未登录，请先登录');
      return;
    }
    
    console.log('当前用户:', session.user.email);
    
    // 2. 测试直接查询
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('credits, email, id, uuid')
      .eq('email', session.user.email)
      .single();
    
    if (userError) {
      console.error('查询用户数据失败:', userError.message);
    } else {
      console.log('用户数据:', userData);
    }
    
    // 3. 测试RPC函数调用
    try {
      const { data: rpcData, error: rpcError } = await supabase.rpc('get_user_credits', {
        user_email: session.user.email
      });
      
      if (rpcError) {
        console.error('RPC调用失败:', rpcError.message);
      } else {
        console.log('RPC返回的积分:', rpcData);
      }
    } catch (e) {
      console.log('RPC函数可能不存在:', e.message);
    }
    
  } catch (error) {
    console.error('测试失败:', error.message);
  }
}

// 执行测试
testCreditsAPI().catch(error => {
  console.error('执行出错:', error);
});
```

## 解决方案

### 方案1：直接在前端修复

在前端代码中添加以下函数，并在用户登录后调用：

```javascript
async function fixCreditsDisplay() {
  // 获取当前会话
  const { data: { session } } = await supabase.auth.getSession();
  
  if (!session) return;
  
  // 获取最新用户数据
  const { data } = await supabase
    .from('users')
    .select('*')
    .eq('email', session.user.email)
    .single();
  
  if (data) {
    // 手动更新前端状态
    // 根据你的前端框架选择适当的方法
    
    // React示例:
    setUser(data);
    
    // Vue示例:
    this.user = data;
    
    // 或者直接更新DOM:
    document.getElementById('user-credits').textContent = data.credits;
  }
}
```

### 方案2：创建自定义API端点

创建一个专门的API端点来获取用户积分：

```sql
-- 在SQL编辑器中执行
CREATE OR REPLACE FUNCTION public.get_user_credits(user_email TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  user_credits INTEGER;
BEGIN
  SELECT credits INTO user_credits
  FROM public.users
  WHERE email = user_email;
  
  RETURN user_credits;
END;
$$;

-- 授予执行权限
GRANT EXECUTE ON FUNCTION public.get_user_credits TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_credits TO anon;
```

然后在前端调用：

```javascript
const { data: credits, error } = await supabase.rpc('get_user_credits', {
  user_email: session.user.email
});

if (!error) {
  // 更新显示
  document.getElementById('user-credits').textContent = credits;
}
```

### 方案3：检查前端组件

确保前端组件正确使用用户数据：

```javascript
// React示例
function CreditsDisplay({ user }) {
  // 添加调试日志
  console.log('用户数据:', user);
  
  // 确保user和credits存在
  const credits = user?.credits ?? 0;
  
  return (
    <div>
      <h3>积分余额</h3>
      <p>{credits}</p>
    </div>
  );
}
```

## 后续步骤

1. 执行上述排查步骤，找出具体问题
2. 根据问题选择适当的解决方案
3. 实施解决方案并测试
4. 如果问题仍然存在，可能需要检查数据库中的触发器或其他可能影响积分的因素